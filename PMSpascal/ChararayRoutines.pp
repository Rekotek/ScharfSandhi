unit chararyroutines;interface	const		linmax = 1000;		pratipadmax = 20;	{Maximum length assumed for lexical items}	type		lenrange = 1..linmax;		lenrange0 = 0..linmax;		lenrangeE = -1..linmax;		linetype = array[lenrange] of char;		stringrange = 1..255;	function lengthary (charary: linetype): lenrange0;{passed a character array[1..linmax]}{returns an integer value in the range 0..linmax = the position of the last character which is not a space in a character array}{if the array is all space characters it returns zero}	function nxtposary (chtr: char; fldch: char; charary: linetype; istart: lenrange): lenrangeE;{passed a character, a character array[1..linmax], an integer 1..linmax}{returns the position of the first occurrence of the character in the array beginning with Charary[Index]}{returns zero if the character is not found; returns -1 if istart is out of bounds}	function lastposary (chtr: char; charary: linetype; istart: lenrange): lenrangeE;{passed a character, a character array[1..linmax], an integer 1..linmax}{returns the position of the first previous occurrence of the character found searching backwards from Charary[Index]}{returns zero if the character is not found; returns -1 if istart is greater than the size of the array}	procedure insertary (chtr: char; var Charary: linetype; index: lenrange; var NoSpace: boolean);{passed an actual character value, a variable character array and an actual value index of an integer in the range 1..linmax}{returns the array with the character inserted at position index and the rest of the array moved over}{If index indexes a position after the last non-space, the character is inserted just after the last non-space character}{It is an error if the array is passed with no space in Charary[linmax]}	procedure deletary (var Charary: linetype; index: lenrange);{passed a variable character array and an actual value index of an integer in the range 1..linmax}{returns the array with the character at position index deleted and the rest of the array moved in}{If index indexes a position after the last non-space, no character is deleted}	function substrary (Charary: linetype; index1: lenrange; index2: lenrange): string;{passed an actual character array Charary and actual integer values index1 and index2}{returns a string consisting of (index1-index2)+1 characters beginning at index1, a substring of the character array}implementation	function lengthary;{passed a character array[1..linmax]}{returns an integer value in the range 0..linmax = the position of the last character which is not a space in a character array}{if the array is all space characters it returns zero}		label			1000;		var			I: integer;			Found: boolean;	begin	Found := false;	for I := linmax downto 1 do		if Charary[I] <> ' ' then begin			Found := true;			goto 1000			end;1000:	if Found then		lengthary := I	else		lengthary := 0;	end;	function nxtposary;{passed a character, a character array[1..linmax], an integer 1..linmax}{returns the position of the first occurrence of the character in the array beginning with Charary[Index]}{returns zero if the character is not found; returns -1 if istart is out of bounds}		label			1000, 9000;		var			I: integer;			IEnd: lenrange0;			Found: boolean;	begin	if (istart < 1) or (istart > linmax) then begin		nxtposary := -1;		goto 9000		end;	IEnd := lengthary(charary);	Found := false;	nxtposary := 0;	for I := istart to IEnd do		if (charary[I] = chtr) or (charary[I] = fldch) then begin			Found := true;			goto 1000			end;1000:	if Found then		nxtposary := I;9000:	end;	function lastposary;{passed a character, a character array[1..linmax], an integer 1..linmax}{returns the position of the first previous occurrence of the character found searching backwards from Charary[Index]}{returns zero if the character is not found; returns -1 if istart is greater than the size of the array}		label			1000, 9000;		var			I: integer;			Found: boolean;	begin	if (istart < 1) or (istart > linmax) then begin		lastposary := -1;		goto 9000		end;	Found := false;	lastposary := 0;	for I := istart downto 1 do		if charary[I] = chtr then begin			Found := true;			goto 1000			end;1000:	if Found then		lastposary := I;9000:	end;	procedure insertary;{passed an actual character value, a variable character array and an actual value index of an integer in the range 1..linmax}{returns the array with the character inserted at position index and the rest of the array moved over}{If index indexes a position after the last non-space, the character is inserted just after the last non-space character}{It is an error if the array is passed with no space in Charary[linmax]}		var			I: integer;			Ipt: lenrange;			IEnd: lenrange0;	begin	NoSpace := false;	IEnd := lengthary(Charary);	if IEnd = linmax then begin		NoSpace := true;		exit(insertary);		end;	Ipt := index;	if Ipt < 1 then		Ipt := 1;	if Ipt > IEnd then		Ipt := IEnd + 1;	for I := IEnd downto Ipt do		Charary[I + 1] := Charary[I];	Charary[Ipt] := chtr;	end;	procedure deletary;{passed a variable character array and an actual value index of an integer in the range 1..linmax}{returns the array with the character at position index deleted and the rest of the array moved in}{If index indexes a position after the last non-space, no character is deleted}		var			I: integer;			IEnd: lenrange0;	begin	IEnd := lengthary(Charary);	if (index >= 1) and (index <= IEnd) then begin		{index = 1..linmax, IEnd = 0..linmax}		for I := index to IEnd - 1 do			Charary[I] := Charary[I + 1];		Charary[IEnd] := ' ';		end;	end;	function substrary;{passed an actual character array Charary and actual integer values index1 and index2}{returns a string consisting of (index1-index2)+1 characters beginning at index1, a substring of the character array}{if the range of characters is too large, a null string is returned}		var			I: integer;			Tempstr: string[255];	begin	substrary := '';	Tempstr := '';	if ((index2 - index1) + 1) <= pratipadmax then		for I := index1 to index2 do			Tempstr := concat(Tempstr, Charary[I]);	Substrary := Tempstr;	end;end.